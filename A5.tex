\documentclass[11pt, answers]{exam}
\renewcommand{\baselinestretch}{1.05}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd, graphicx}
\usepackage{graphics}

\usepackage{afterpage}
\usepackage{caption}

\usepackage{tikz}
\usepackage{fancybox}

\usepackage{clrscode3e}

\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem*{surfacecor}{Corollary 1}
\newtheorem{conjecture}{Conjecture}  
\theoremstyle{definition}
\newtheorem{definition}{Definition}

 \begin{document}
 


\title{CSC263: Assignment 5}
\date{March 30th, 2017}
\author{Junjie Cheng, Jiayun Liu, Zi Hao Lin}
\maketitle

\unframedsolutions

\begin{questions}
\question
%Question1
\begin{solution}
\begin{lemma}
For any undirected connected graph $G=(V,E)$, choose an arbitrary vertex $v \in V$, then for all $u \in V$, $u$ is reachable by $v$. That is, the predecessor subgraph of a depth-first search on the undirected graph forms only one depth-first tree.
\end{lemma}
This lemma follows immediately by the property of connected graph and undirected graph.
\begin{lemma}
Perform DFS on any undirected connected graph $G=(V,E)$, there must be at least one node in the corresponding depth-first tree such that it is either a leaf (connected by only one tree edge) or a node whose all (immediate) descendants are connected by back edges. Moreover, the last discovered vertex during the DFS procedure is such a node.
\end{lemma}
The proof for this lemma is also easy. Consider a DFS on an arbitrary undirected connected graph $G=(V,E)$. Consider the last vertex discovered by the algorithm. Let's name it $m$. If $|V| = 1$, then $m$ must be a leaf. Now suppose $|V|>1$. Since $m$ is discovered by its (immediate) ancestor $m.\pi$, $m$'s adjacent list must contain $m.\pi$. Note that $m$'s adjacent list can either contain other vertices or does not contain other vertex than $m.\pi$. In the prior case, since all vertices are reachable by any vertex in the graph, $m$'s (immediate) descendants must be at least discovered by DFS (or $m$ cannot be the last vertex discovered by the algorithm); $m$'s (immediate) descendants cannot be black as well, since it is impossible to discover a black node in undirected graph. So all $m$'s (immediate) descendants are gray, i.e. $m$ and all its (immediate) descendants are connected by back edges. In the latter case, $m$ will not have any descendant, thus is a leaf
\begin{lemma}
Removing a vertex $m$ that is a leaf or a node whose all (immediate) descendants are connected by back edges in a depth-first tree will not disconnect the tree. 
\end{lemma}
If $|V| = 1$ then after removal the graph is vacuouly connected. If $|V| >1$ then we can do proof by cases. If $m$ is a leaf in a depth-first tree, it's ancestor $m.\pi$ is still connected by $m.\pi.\pi$, and any other vertices in the graph will not be affected by the removal. If $m$ is a node whose all (immediate) descendants are connected by back edges, then again, its ancestor and all its descendants are still connected by their ancestors. In either case, after removal, all nodes' ancestors persists, i.e. every node still have a path back to the root vertex (by recursively stepping to the ancestor of the current node). So all vertices in the tree are still reachable by the root vertex. Since the depth-first tree contains all vertices in the graph (by lemma 1), the graph is not disconnected after the removal of $m$ along with all incident edges.

Our algorithm is a slightly modified version of DFS. We want to find the last white node in the DFS algorithm.
When coloring all the vertices, we count the total number of vertices in the graph. We use another counter to keep track of the white nodes discovered upon each discovery. 

\begin{codebox}
 $white\_counter = 0$ //{global variable} \\
 $vertex\_counter = 0$ //{global variable}
\end{codebox}
\begin{codebox}
\Procname{$\proc{DFS}(G)$}
\li $vertex\_counter = 0$
\li \For {each vertex} $u \in G.V$ \Do
\li     $u.color = WHITE$
\li     $u.\pi = NIL$
\li     $vertex\_counter += 1$ \End
\li $white\_counter = 0$
\li \For {each vertex} $u \in G.V$ \Do
\li     \If $u.color == WHITE$ \Then 
\li         $white\_counter ++$
\li         \If $white\_counter == vertex\_counter$ \Then
\li             \Return $u$\End
\li         \Return $\proc{DFS-Visit}(G,u)$ //{Since G is connected and undirected, $u$ can reach all vertices}
\End\End
\end{codebox}
\begin{codebox}
\Procname{$\proc{DFS-Visit}(G, u)$}
\li $u.color =GRAY$
\li \For {each} $v \in G.Adj[u]$ \Do
\li     \If $v.color == WHITE$ \Then
\li         $v.\pi = u$
\li         $white\_counter++$
\li         \If $white\_counter == vertex\_counter$ \Then
\li             \Return $v$
\li         \Else 
\li             $x = \proc{DFS-Visit}(G,u)$
\li             \If $x != NIL$ \Then
\li                 $removable = x$ \End\End\End\End
\li $u.color = BLACK$
\li \Return $removable$
\end{codebox}

Correctness: 

We proved that the last white node (vertex)'s removal does not disconnect the graph. So we only need to prove this algorithm finds the last white node correctly.

Assume there are $n$ vertices in the graph. After the first for loop in $\proc{DFS}(G)$, we will have $vertex\_counter = n$. If $|V| = 1$ then the condition in line 10 is true and the returned $u$ is indeed the last white node because there is only one vertex in the graph. Now assume $|V|>1$.

By lemma 1, since every vertex is reachable by an arbitrary vertex, it is safe to call $\proc{DFS-Visit}(G,u)$ only once in $\proc{DFS}(G)$. Again, since every vertex is reachable, every (initially white) vertex will be discovered once by the DFS, so a total of $n$ white nodes will be visited and it is always the case that $white\_counter$ reaches $n$. So, there must be a time that $\proc{DFS-Visit}(G,u)$ returns a vertex. Let's say the returned vertex is $p$. According to the $white\_counter$, $p$ must be the last white vertix discovered. Note that $\proc{DFS-Visit}(G,p)$ returns $p$, in the previous recursive call, $\proc{DFS-Visit}(G,p.\pi)$, in some iteration of the for loop, line 9 must return $p$, so $removable$ gets the vertex point $p$ and gets returned in line 13.

By doing induction backwards, we can say that the first function call of $\proc{DFS-Visit}(G,u)$ also returns $p$. That is, on line 12 of $\proc{DFS}(G)$, $p$, the last white vertex discovered by DFS, is returned. By lemma 2 and lemma 3, the algorithm is correct.

Time complexity:

The worst case complexity of DFS is $O(|V|+|E|)$. In our modified version, we only add $white\_counter$ and $vertex\_counter$ in the code. $vertex\_counter$ is accumulated once for each vertex, taking additional $O(|V|)$ time; $white\_counter$'s increment and the following conditional statements are executed only when encountering a new white vertex. Since there are $O(|V|)$ white vertices initially and as soon as white vertex is discovered it is turned gray, the execution of the increment of $white\_counter$ and the following conditional statements should take $O(|V|)$as well. So, our algorithm takes $$O(|V|+|E|)+O(|V|)+O(|V|)=O(|V|+|E|)$$ in the worst case.

\end{solution}

\question
%Question2
\begin{solution}
\begin{parts}
\part 
Assume there exist a bipartite G that contains a simple circle of odd length.

Start with any vertex and name each vertex in this circle in order with $v_1$,$v_2$...$v_{2k+1}$. Every two adjacent vertexes are connected by an edge, and since it is a circle, $v_{2k+1}$ is connected with $v_1$.

For all $v_i$, it will be put into V1 if i is odd and V2 if i is even. As a result, until $v_{2k}$, no two connected vertexes will be put into the same subset.
 
However, $v_{2k+1}$ will inevitably be put into V1, which is the same set of $v_1$. By the principle of bipartite, no two connected vertexes can be put into the same V, so there is a contradiction.

Thus, a bipartite G contains no simple circle of odd length.

\part
General idea: We are going to perform a BFS and use the distance. If d[v] is odd, then put v into V1, if d[v] is even, then put v into V2.

Proof:

 \textbf{Base case:}

If v is the only vertex with d[v], then d[v] = d[s] = 0, put it into V2. 

If v and u are the only two vertexes and v discovers u, then d[v] = 0, d[u] = d[v] + 1 = 1. As a result, v is in V2, u is in V1, and the two connected vertexes are in different subsets. This satisfies the principle of bipartite.

\textbf{Induction:}

\textbf{I.H:} 

Suppose all vertexes before v (include v) are put into V1 and V2 and satisfy the condition of bipartite. Assume every circle in G has even length and v connect to u.

\textbf{I.S:}

By the principle of BFS, as u is connect to v, then:

\textbf{Case 1}: u is white

Then d[u] = d[v] + 1. 

Then if d[v] is odd, then d[u] is even, vice versa.

Then u and v will be in two different V, which satisfy the bipartite condition for any v and u.

\textbf{Case 2}: u is gray or black

Now we meet a circle. 

As every circle given has even length, if we start from u to v, by principle of BFS, d[u] = d[v] + 2k +1 where k is the number of vertexes in the circle.

So u and v will still be in different V, the graph with u, v is bipartite.

Induction follows.

\part
The algorithm:

Run BFS and put vertexes into V1 and V2 according to part(b).

Every time when v discovers u and u is grey or black, check if (d[v] - d[u] - 1) $\%$ 2 = 0.

If true, then we meet an even circle, keep going.

If false, then we meet an odd circle, return "Not bipartite".


Running time:

In the algorithm, both putting vertexes into subset or checking even or odd circles only need some simple steps and run constant time.

Therefore, the running time will be same as BFS(G,s), which is O(m+n).




\end{parts}
\end{solution}


\question
%Question3
\begin{solution}
\begin{parts}
\part
Vertices: $n$ bike pump stations positioned at their corresponding $(x,y)$-coordinates.

Edges: There is an edge between any two vertices (bike pump stations), so there are a total of $\frac{n(n-1)}{2}$ edges, if we assume that there is no overlap.

Edge weights: The distance between the two corresponding bike pump stations (vertices). The edge weight for edge $(u,v)$ can be calculated by $\sqrt{(x_v - x_u)^2+(y_v - y_u)^2}$.

Problem: A set of vertices $V$ is given. Each vertex $v \in V$ is positioned at $(x_v, y_v)$, and there is an edge $(u,v)$ between any two distinct vertices $u \in V, v \in V$ with the edge weight $\sqrt{(x_v - x_u)^2+(y_v - y_u)^2}$. Goal: given $s \in V, t \in V$, find a path from $s$ to $t$ such that the edge weight of each edge on that path is minimized.

\part
The Minimal Spanning Tree generated by Kruskal’s algorithm can be used to find the desired path efficiently.

\part
The algorithm:

First, generate $E$ the set of edges. For each two distinct vertices $u, v$ in the vertex set $V$, make an edge $(u,v)$ and add it into the set $E$.

Then for each edge $(u,v)$, calculate the edge weight $\sqrt{(x_v - x_u)^2+(y_v - y_u)^2}$ and store it into $(u.v).weight$.

Next, Use Kruskal's algorithm to generate a MST $M$. 

Then perform $\proc{DFS-Visit}(M,s)$ to generate a corresponding depth-first tree $D$, and return the node that represents $t$. 

In the corresponding depth-first tree $D$, start from $t$, denote it $current\_node$, traverse back to $s$ by recursively stepping to the ancestor of $current\_node$. When traversing, record the edge formed by $current\_node$ and its ancestor $current\_node.\pi$. The recorded edges are the solution. 

\part
To generate the set of edges, a simple way is to find all possible combinations of $(u,v)$ by a outer loop on $u$ and a inner loop on $v$. This takes $O(n^2)$ time in the worst case. Adding the edges into the set and calculating the edge weights also takes $O(n^2)$ time in the worst case since there are  $\frac{n(n-1)}{2}$ edges in total, and both adding elements into a set and calculation takes constant time.

The Kruskal's algorithm has the worst-case time complexity $O(E\log{E})$. Note that in this question, every two vertice generates an edge, so there are $\frac{n(n-1)}{2}$ edges for $n$ vertices. The worst-case time complexity for Kruskal's algorithm is now $O(E\log{E}) = O(\frac{n(n-1)}{2}\log{\frac{n(n-1)}{2}}) =O(n^2 \log{n^2}) = O(2n^2 \log{n}) = O(n^2 \log{n})$.

Performing $\proc{DFS-Visit}(M,s)$ takes $O(|E_M|+|V_M|)$ time in the worst case. Note that an MST with $n$ vertices contains only $n-1$ edges. So Performing $\proc{DFS-Visit}(M,s)$ takes $O(|E_M|+|V_M|) = O(n-1+n) = O(n)$ time in the worst case.

The time to traverse from $t$ back to $s$ depends on the number of edges on the path. Noth that the depth-first tree contains $n-1$ edges (because the MST has only $n-1$ edges), the path from $t$ to $s$ should contain at most $n-1$ edges. Traversing on each edge takes constant time, so the traversing takes $O((n-1)*1)= O(n)$ time in the worst case.

So the worst-case running time for the whole algorithm is 
$$O(n^2) + O(n^2) + O(n^2 \log{n}) + O(n) + O(n) =  O(n^2 \log{n})$$.

\end{parts}
\end{solution}

\end{questions}
\end{document}
